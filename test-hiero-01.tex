\documentclass{article}
\usepackage{fontspec}
\usepackage{amsmath,stackengine,luacode,xcolor,listings,
            filecontents,lipsum,graphicx,listings,caption}
\begin{document}
\newfontfamily\hiero{NotoSansEgyptianHieroglyphs-Regular.ttf}
%\newfontfamily\aegyptusi{NewGardiner.ttf}
\newfontfamily\aegyptus{JSeshFont.ttf}
\newfontfamily\arial{Arial Unicode MS}
\parindent0pt
\raggedright


\begin{luacode*}
    local h = {}
          h = dofile("hiero.lua")
    local options = {style="block",
                     echo=true,
                     direction="RL",
                     size = "\\Huge",
                     color = "green",
                     headings = "captionof{figure}"  -- section/tablecaption/figurecaption
                     }
   -- prints full symbol list
   h.printgardiner(t,options)

   tex.print("\\par")
   local options = {style="block",
                     echo=true,
                     heading="\\par",
                     direction="RL",
                     color = "teal",
                     scale = 8}

   h.printhierochar("aegyptus","1317D",options)
   h.printhierochar("aegyptus","13000",{direction="RL",
                                        color = "teal",
                                        scale = 8})
   h.printhierochar("aegyptus","13003",{direction="LR",
                                        color = "teal",
                                        scale = 1})
   h.parseMdC([[M23-X1-R4-X8-Q2-D4-W17-R14-G4-R8-O29-
               V30-U23-N26-D58-O49-Z1-F13-N31-V30-N16-
               N21-Z1-D45-N25!]])

   tex.print("\\par")
   h.printgardinercat("B")

\end{luacode*}

\newcommand\hierochar[2][direction = "LR",
                         color     = "teal",
                         scale     = 1]{% 
               \luaexec{
                h = h or {}
                h = require("hiero.lua")  
                h.parseMdC(#2,{#1})}}
               
\newcommand\printhierochar[3][direction = "LR",
                              color     = "teal",
                              scale     = 4]{% 
               \luaexec{
                h = h or {}
                h = require("hiero.lua")  
                h.printhierochar(#2,#3,{#1})}}

This file just tests the various commands available for manipulating hieroglyphics. We tried to 
generalize the commands, so they can be re-used for other type of hieroglyphics.

\hierochar{"A1-A2-A3!"}

\centering 

\def\options{direction = "LR",
             color     = "teal",
             scale     = 7}

\def\fontname{"aegyptus"}

\def\hierochar#1{\printhierochar[\options]{\fontname}{#1}}

\hierochar{"13051"}
\kern-4mm
\hierochar{"13003"}


\end{document}




\begin{luacode*}
local f = fontloader.open
("c:/windows/fonts/NotoSansEgyptianHieroglyphs-Regular.ttf")
fonttable = fontloader.to_table(f)

fontloader.close(f)


tex.print(fonttable.design_size*6553.6)

tex.print(fonttable)
local size=1
size = size * tex.sp("10pt") / -1000
tex.print(size)

tf=fontloader.info("c:/windows/fonts/NotoSansEgyptianHieroglyphs-Regular.ttf")
tex.print("\\par",tf.fontname,"\\par",
          tf.fullname,"\\par",
          tf.familyname,"\\par")




function toHex(num)
  local  num  = string.format("%x", num)
         num  = string.upper(num)
  return num
end

function prettyprint ()
    tex.print("\\footnotesize")
    f=fontloader.open("c:/windows/fonts/JSeshFont.ttf")
    tex.print (f.fontname.."\\par")
    
	
    local i = 3
    local glyphname
	while (i <f.glyphmax ) do -- use f.glyphmax 
		local g = f.glyphs[i]
		local uhex
       
		if g then
      		glyphname = string.sub(g.unicode,2) 
 	   		uhex = toHex(g.unicode)
 			tex.print(""..glyphname.."=U+"..toHex(g.unicode)..", ")
 			printglyphRL("aegyptus", uhex) -- texprints the glyph
		end
  		i = i + 1
	end
	fontloader.close(f)
end

prettyprint()

local n = font.max()

tex.print("highest font number",n)

number, metrics=font.each()
--for key,value in pairs(metrics) do tex.print(key,value) end

tex.print(metrics)
metrics = font.getfont(21)
map = fonttable.map.map
local glyph = fonttable.glyphs[map[78200]]

tex.print("Glyph width",glyph.width)
tex.print("Glyph name",glyph.name,"\\par")
tex.print("Glyph unicode",glyph.unicode,"\\par")
tex.print("Glyph boundingbox[1]",glyph.boundingbox[1],"\\par")
tex.print("Glyph boundingbox[2]",glyph.boundingbox[2],"\\par")
tex.print("Glyph boundingbox[3]",glyph.boundingbox[3],"\\par")
tex.print("Glyph boundingbox[4]",glyph.boundingbox[4],"\\par")
--tex.print("Glyph boundingbox[5]",glyph.boundingbox[5],"\\par")
--tex.print("Glyph boundingbox[6]",glyph.boundingbox[6],"\\par")

tex.print(glyph.class,"\\par")
tex.print(font.current())

local g = node.new("glyph")
g.font = font.current()
g.lang = tex.language
g.char = 7824 -- U+13410

local hbox = node.hpack(g)
local vbox = node.vpack(hbox)

node.write(vbox)
\end{luacode*}
\arial

\aegyptus
\par
\begin{luacode*}
local g = node.new("glyph")

g.lang = tex.language
g.char = 80 -- U+13410

local hbox = node.hpack(g)
local vbox = node.vpack(hbox)

node.write(vbox)
\end{luacode*}

\aegyptus

\char8890
\end{document}
% We provide some author commands to assist
% with typesetting a hieroglyphics string 


% Use as |\hieroprint{"D50-D50a-D50b-D50i!"}| to
% print \hieroprint{"D50-D50a-D50b-D50i!"}

% The string must be quoted, otherwise Lua will be
% looking for a string variable. Some variables are build
% for example \hieroprint{women} will print Gardiner's list
% of `women and their occupations.'

\resizebox{!}{2cm}{\hiero\char"13000}\\
\resizebox{.6cm}{!}{\hiero\char"13000}\resizebox{.6cm}{!}{\hiero\char"13000}\resizebox{.6cm}{!}{\hiero\char"13000}

\cxset{geometry units=mm}
\drawfontbox{\resizebox{!}{2cm}{\hiero\char"130B3}}
\drawfontbox{\resizebox{!}{1cm}{\hbox{\hiero\char"13000\char"13000}}}


\drawfontbox{\resizebox{51.05pt}{!}{\hiero\char"13000\char"1306D\char"13000}}


This is using \verb+\shortunderstack+

abcde f \Shortunderstack[c]{{\hiero\char"13000} {\hiero\char"13001} {\hiero\char"13002\char"13006}} gyu\par

abcde f \Shortstack[c]{{\hiero\char"13000} {\hiero\char"13001} {\hiero\char"13070\char"1308A\char"1308B}} gyu\par

This is \resizebox{2.5em}{!}{\fbox{\Huge\hsize=1em\vbox{%
\hiero\char"1308F\par
\char"130BB
}}}
\resizebox{2.5em}{!}{\fbox{\Huge\hsize=1em\vbox{%
\hiero\char"1309F\par
\char"130BB
}}}

\Huge
$$\stackrel{\mbox{\hiero\char"1309F}}{\mbox{\hiero\char"130BB}}    $$

$$\mbox{\fontsize{3em}{1em}\selectfont\hiero \char"13005}\overset{\mbox{\hiero\char"13000\char"13000}}{\overset{\scalebox{-1}[1]{\hiero\char"1309F}}{\scalebox{-1}[1]{\hiero\char"13000}}}$$

$$\mbox{\fontsize{3em}{1em}\selectfont\hiero \char"13005}\overset{\mbox{\hiero\char"13000\char"13000}}{\overset{\scalebox{-1}[1]{\hiero\char"1309F}}{\scalebox{-1}[1]{\hiero\char"13000}}}$$

$$\mbox{\fontsize{3em}{1em}\selectfont\hiero \char"13005}\overset{\mbox{\hiero\char"13000\char"13000}}{\overset{\scalebox{-1}[1]{\hiero\char"1309F}}{\mbox{}}}$$

\normalsize

\arial
\begin{luacode*}
local g = node.new("glyph")
g.font = font.current()
g.lang = tex.language
g.char = 7824 -- U+13410

local hbox = node.hpack(g)
local vbox = node.vpack(hbox)

node.write(vbox)
\end{luacode*}
\end{document}


{\Huge
$$\text{\hiero\char"13000}\frac{\text{\hiero \char"13000\char"13001}}{\text{\hiero \char"130FE\char"130FF}}$$
}


$\stackrel{\hbox to 3em{\hiero\hfill\char"13001\hfill}}{\hbox to 3em{\hiero \hfill\char"130FE\char"130FF\hfill}}$

\begin{lstlisting}[language={[5.2]Lua},
basicstyle=\ttfamily\footnotesize,
keywordstyle=\bfseries\color{blue},
 stringstyle=\color{orange},
 commentstyle=\color{green},
]
-- test
local words = io.open('hyphens-' .. tex.jobname .. '.txt', 'w');
local outchar = unicode.utf8.char
local function dumphyphens (head)
   local data = {}
   for v in node.traverse(head) do
       if v.id == node.id('glyph') then
         data[#data+1] = outchar(v.char);
       elseif v.id == node.id('disc') then
          data[#data+1] = '-'
       elseif v.id == node.id('glue') then
         data[#data+1] = outchar(32)
       elseif v.id == node.id('hlist') then
         data[#data+1] = dumphyphens(v.list)
       end
   end
   return table.concat(data)
end
callback.register ('hyphenate', function (head,tail)
   lang.hyphenate(head, tail) 
   words:write (dumphyphens(head) .. outchar(10))
   end)
\end{lstlisting}




\end{document}
\Large
\scalebox{-2}[2]{\hiero\char"13000\char"13011\char"13020}

\scalebox{2}[2]{\hiero\char"13000\char"13011\char"13020}
\end{document}

removing a specific number of lines

\begin{luacode*}
function remove( filename, starting_line, num_lines )
    local fp = io.open( filename, "r" )
    if fp == nil then return nil end
 
    content = {}
    i = 1;
    for line in fp:lines() do
        if i < starting_line or i >= starting_line + num_lines then
	    content[#content+1] = line
	end
	i = i + 1
    end
 
    if i > starting_line and i < starting_line + num_lines then
	print( "Warning: Tried to remove lines after EOF." )
    end
 
    fp:close()
    fp = io.open( filename, "w+" )
 
    for i = 1, #content do
	 fp:write( string.format( "%s\n", content[i] ) )
    end
 
    fp:close()
end
remove("input.txt",3,2)

filename = "./languages/hieroglyphics.txt"
fp = io.open( filename, "r" )
for line in fp:lines() do
    tex.print(line.."\\par")
end
fp:close()

--If the file opens with no problems, io.open will return a
--handle to the file with methods attached.
--If the file does not exist, io.open will return nil and
--an error message.
--assert will return the handle to the file if present, or
--it will throw an error with the message returned second
--by io.open.
local file = assert(io.open(filename))
--Without wrapping io.open in an assert, local file would be nil,
--which would cause an 'attempt to index a nil value' error when
--calling file:read.
 
--file:read takes the number of bytes to read, or a string for
--special cases, such as "*a" to read the entire file.
local contents = file:read'*a'
 
--If the file handle was local to the expression
--(ie. "assert(io.open(filename)):read'a'"),
--the file would remain open until its handle was
--garbage collected.
tex.sprint(contents)
file:close()
\end{luacode*}
















\end{document}